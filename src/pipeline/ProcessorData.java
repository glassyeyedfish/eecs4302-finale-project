package pipeline;

import java.util.ArrayList;
import java.util.List;

public class ProcessorData {
	
	// NOTE: This class should render the CoverageData class obsolete.
	
	/*
	 * TODO: Serialize and expose all this data.
	 */
	
	// Generated by initial processor.
	public List<DCPath> allDCPaths;
	public List<Integer> allStatements;
	public List<Integer> allDecisions;
	
	// Generated by test interpreters.
	public List<DCPath> coveredDCPaths;
	public List<Integer> coveredStatements;
	public List<Integer> coveredDecisions;
	
	// The output coverage data. These should just be subsets of what's above.
	// Generated by coverage tests.
	
	// NOTE: There is no need for extra data in statement coverage, because
	// the list of coveredStatements (from above) is sufficient.
	
	// Data Flow
	public List<DCPath> coveredForAllDefs;
	public List<DCPath> requiredForAllDefs;
	
	public List<DCPath> coveredForAllCUses;
	public List<DCPath> requiredForAllCUses;
	
	public List<DCPath> coveredForAllPUses;
	public List<DCPath> requiredForAllPUses;
	
	public void coverPathAt(int lineNum) {
		for (DCPath path: this.allDCPaths) {
			if (path.getLineTo() == lineNum && !this.coveredDCPaths.contains(path)) {
				this.coveredDCPaths.add(path);
			}
		}
	}
	
	public void coverStatementAt(int lineNum) {
		for (Integer line: this.allStatements) {
			if (line == lineNum && !this.coveredStatements.contains(line)) {
				this.coveredStatements.add(line);
			}
		}
	}

	public ProcessorData() {
		this.allDCPaths = new ArrayList<>();
		this.allStatements = new ArrayList<>();
		this.allDecisions = new ArrayList<>();
		
		this.coveredDCPaths = new ArrayList<>();
		this.coveredStatements = new ArrayList<>();
		this.coveredDecisions = new ArrayList<>();
		
		this.coveredForAllDefs = new ArrayList<>();
		this.requiredForAllDefs = new ArrayList<>();
		
		this.coveredForAllCUses = new ArrayList<>();
		this.requiredForAllCUses = new ArrayList<>();
		
		this.coveredForAllPUses = new ArrayList<>();
		this.requiredForAllPUses = new ArrayList<>();
	}
}
