package pipeline;

import java.util.Comparator;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import proglang.model.*;
import proglang.model.expressions.*;
import testlang.model.*;

public class Processor {
	
	/*
	 * Walk through PLProgram and generate the following data:
	 * 	
	 * 	- allDCPaths
	 *  - allStatements
	 *  - allDecisions
	 */
	public ProcessorData processPLFunction(PLFunction<?> func) {
		/* the data being generated by the processor */
		ProcessorData data = new ProcessorData();
		DCPath path;
		
		// Function's line number
		if (!data.allStatements.contains(func.getStartLineNum()))
			data.allStatements.add(func.getStartLineNum());
		
		/* 
		 * Loop through each of the declarations and function parameters to 
		 * start each DCPath.
		 */
		for (Map.Entry<String, PLDeclaration> entry: func.getVariables().entrySet()) {
			// control flow coverage
			if (!data.allStatements.contains(entry.getValue().getLineNum()))
				data.allStatements.add(entry.getValue().getLineNum());
			
			path = new DCPath(entry.getValue().getLineNum(), entry.getKey());
			
			/*
			 * Loop thorugh each statement in the function and...
			 * 	- Add each statement as a new DCPath if it's a c-use or p-use
			 *  - Start a new DCPath when we've hit a definition.
			 */
			for (PLStatement stmt: func.getStatements()) {
				processPLStatement(entry, stmt, data, path);
			}
			
			if (func.getRtrnStmt() != null) {
				processPLStatement(entry, func.getRtrnStmt(), data, path);
			}
		}
		
		// Sort line numbers
		data.allStatements.sort(Comparator.naturalOrder());
		
		return data;
	}
	
	private void processPLStatement(
			Map.Entry<String, PLDeclaration> entry, 
			PLStatement stmt, 
			ProcessorData data,
			DCPath path
	) {
//		System.out.println(stmt.getLineNum() + " : " + stmt);
//		
//		if (stmt instanceof PLAssignment) {
//			PLAssignment<?> a = (PLAssignment<?>) stmt;
//			System.out.println(((PLIntegerFunctionCall) a.getExpression()).getArguments());
//		}
		
		/*
		 * This is a three step process
		 * 
		 * 1. Check to see if we've hit a P-Use
		 * 2. Check to see if we've hit a C-Use
		 * 3. Check to see if we've hit a Definition
		 * 
		 * These checks are used to generate all possible definition clear 
		 * paths inside of a function
		 */
		
		/*
		 * Here is where we check for P-Uses
		 */
		if (stmt instanceof PLConditional) {
			
			if (((PLConditional) stmt).getExpression().hasVariable(entry.getKey())) {
				// control flow coverage
				if (!data.allStatements.contains(stmt.getLineNum()))
					data.allStatements.add(stmt.getLineNum());
				if (!data.allDecisions.contains(stmt.getLineNum()))
					data.allDecisions.add(stmt.getLineNum());
				
				// data flow coverage
				path.setLineTo(stmt.getLineNum());
				path.setCUse(false);
				
				path.setpUseCondition(true);
				data.allDCPaths.add(path.clone());
				
				path.setpUseCondition(false);
				data.allDCPaths.add(path.clone());
			}
		}

		/*
		 * Here is where we check for C-Uses
		 */
		if (stmt.hasVariable(entry.getKey())) {
			// control flow coverage
			if (!data.allStatements.contains(stmt.getLineNum()))
				data.allStatements.add(stmt.getLineNum());
			
			// data flow coverage
			if (
				   stmt instanceof PLPrint 
				|| stmt instanceof PLAssignment 
				|| stmt instanceof PLReturn<?>
			) {
				path.setLineTo(stmt.getLineNum());
				path.setCUse(true);
				
				data.allDCPaths.add(path.clone());
			} else if (stmt instanceof PLConditional) {
				/*
				 * When we hit a conditional, we have to remember the last 
				 * line from the DCPath right before we explore the if 
				 * statement, so that way we can reset it to that lineFrom when 
				 * we are finished searching the if statement.
				 */
				
				int preLineFrom = path.getLineFrom();
				
				for (PLStatement innerStmt: ((PLConditional) stmt).getStatements()) {
					processPLStatement(entry, innerStmt, data, path);
				}
				
				path.setLineFrom(preLineFrom);
			} else if (stmt instanceof PLFunctionCall) {
			}
		}
		
		/*
		 * Here we check for new definitions
		 */
		if (stmt instanceof PLAssignment) {
			// control flow coverage
			if (!data.allStatements.contains(stmt.getLineNum()))
				data.allStatements.add(stmt.getLineNum());
			
			// data flow coverage
			if (((PLAssignment<?>) stmt).getId().equals(entry.getKey())) {
				path.setLineFrom(stmt.getLineNum());
			}
		}
	}
	
	/*
	 * Code Coverage generators.
	 */
	public void generateAllDefs(ProcessorData data) {
		Set<String> coveredVars = new HashSet();
		
		// Find all covered definitions
		for (DCPath path: data.coveredDCPaths) {
			coveredVars.add(path.getId());
		}
	}

	public void generateAllCUses(ProcessorData data) {
		// TODO implement
	}

	public void generateAllPUses(ProcessorData data) {
		// TODO implement
	}
}
