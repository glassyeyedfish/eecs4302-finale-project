package pipeline;

import java.util.Comparator;
import java.util.Map;
import proglang.model.*;

public class Processor {
	
	/*
	 * Walk through PLProgram and generate the following data:
	 * 	
	 * 	- allDCPaths
	 *  - allStatements
	 *  - allDecisions
	 */
	public ProcessorData processPLProgram(PLProgram prog) {
		/* the data being generated by the processor */
		ProcessorData data = new ProcessorData();
		DCPath path;
		
		for (Map.Entry<String, PLFunction> funcEntry: prog.getFunctions().entrySet()) {
			PLFunction<?> func = funcEntry.getValue();
			
			// Function's line number
			if (!data.allStatements.contains(func.getStartLineNum()))
				data.allStatements.add(func.getStartLineNum());
			if (!data.allStatements.contains(func.getEndLineNum()))
				data.allStatements.add(func.getEndLineNum());
			
			/* 
			 * Loop through each of the declarations and function parameters to 
			 * start each DCPath.
			 */
			boolean ranOnce = false;
			for (Map.Entry<String, PLDeclaration> entry: func.getVariables().entrySet()) {
				ranOnce = true;
				// control flow coverage
				if (!data.allStatements.contains(entry.getValue().getLineNum()))
					data.allStatements.add(entry.getValue().getLineNum());
				
				path = new DCPath(
						entry.getValue().getLineNum(), 
						func.getName() + ":" + entry.getKey());
				
				/*
				 * Loop thorugh each statement in the function and...
				 * 	- Add each statement as a new DCPath if it's a c-use or p-use
				 *  - Start a new DCPath when we've hit a definition.
				 */
				for (PLStatement stmt: func.getStatements()) {
					processPLStatement(entry, stmt, data, path);
				}
				
				if (func.getRtrnStmt() != null) {
					processPLStatement(entry, func.getRtrnStmt(), data, path);
				}
			}
			if (!ranOnce) {
				/*
				 * Loop thorugh each statement in the function and...
				 * 	- Add each statement as a new DCPath if it's a c-use or p-use
				 *  - Start a new DCPath when we've hit a definition.
				 */
				for (PLStatement stmt: func.getStatements()) {
					processPLStatement(null, stmt, data, null);
				}
				
				if (func.getRtrnStmt() != null) {
					processPLStatement(null, func.getRtrnStmt(), data, null);
				}
			}
		}
		
		// Sort line numbers
		data.allStatements.sort(Comparator.naturalOrder());
		data.allDecisions.sort(Comparator.naturalOrder());
		
		return data;
	}
	
	private void processPLStatement(
			Map.Entry<String, PLDeclaration> entry, 
			PLStatement stmt, 
			ProcessorData data,
			DCPath path
	) {
		/*
		 * This is a three step process
		 * 
		 * 1. Check to see if we've hit a P-Use
		 * 2. Check to see if we've hit a C-Use
		 * 3. Check to see if we've hit a Definition
		 * 
		 * These checks are used to generate all possible definition clear 
		 * paths inside of a function
		 */
		
		/*
		 * Here is where we check for P-Uses
		 */
		if (stmt instanceof PLConditional) {
			if (!data.allStatements.contains(stmt.getLineNum()))
				data.allStatements.add(stmt.getLineNum());
			
			if (((PLConditional) stmt).getExpression().hasVariable(entry.getKey())) {
				// control flow coverage
				
				if (!data.allDecisions.contains(stmt.getLineNum()))
					data.allDecisions.add(stmt.getLineNum());
				
				// data flow coverage
				path.setLineTo(stmt.getLineNum());
				path.setCUse(false);
				
				path.setpUseCondition(true);
				data.allDCPaths.add(path.clone());
				
				path.setpUseCondition(false);
				data.allDCPaths.add(path.clone());
			}
		}

		/*
		 * Here is where we check for C-Uses
		 */
		// control flow coverage
		if (!data.allStatements.contains(stmt.getLineNum()))
			data.allStatements.add(stmt.getLineNum());
		
		if (entry != null && stmt.hasVariable(entry.getKey())) {
			
			
			// data flow coverage
			if (
				   stmt instanceof PLPrint 
				|| stmt instanceof PLAssignment 
				|| stmt instanceof PLReturn<?>
				|| stmt instanceof PLFunctionCall
			) {
				path.setLineTo(stmt.getLineNum());
				path.setCUse(true);
				
				data.allDCPaths.add(path.clone());
			} else if (stmt instanceof PLConditional) {
				/*
				 * When we hit a conditional, we have to remember the last 
				 * line from the DCPath right before we explore the if 
				 * statement, so that way we can reset it to that lineFrom when 
				 * we are finished searching the if statement.
				 */
				
				/*
				 * Condition EOL add
				 */
				if (!data.allStatements.contains(((PLConditional) stmt).getEndLineNum()))
					data.allStatements.add(((PLConditional) stmt).getEndLineNum());
				
				int preLineFrom = path.getLineFrom();
				
				for (PLStatement innerStmt: ((PLConditional) stmt).getStatements()) {
					processPLStatement(entry, innerStmt, data, path);
				}
				
				path.setLineFrom(preLineFrom);
			}
		} else {
			if (stmt instanceof PLConditional) {
				if (!data.allStatements.contains(((PLConditional) stmt).getEndLineNum()))
					data.allStatements.add(((PLConditional) stmt).getEndLineNum());
				
				int preLineFrom = path.getLineFrom();
				
				for (PLStatement innerStmt: ((PLConditional) stmt).getStatements()) {
					processPLStatement(entry, innerStmt, data, path);
				}
				
				path.setLineFrom(preLineFrom);
			}
		}
		
		/*
		 * Here we check for new definitions
		 */
		if (stmt instanceof PLAssignment) {
			// control flow coverage
			if (!data.allStatements.contains(stmt.getLineNum()))
				data.allStatements.add(stmt.getLineNum());
			
			// data flow coverage
			if (((PLAssignment<?>) stmt).getId().equals(entry.getKey())) {
				path.setLineFrom(stmt.getLineNum());
			}
		}
	}
	
	/*
	 * Code Coverage generators.
	 */
	public void generateAllDefs(ProcessorData data, PLProgram prog) {
		// See what needs to be covered
		for (DCPath path: data.allDCPaths) {
			if (!data.requiredForAllDefs.contains(path.getId())) {
				data.requiredForAllDefs.add(path.getId());
			}
		}
		
		// Add those line numbers.
		for (String s: data.requiredForAllDefs) {
			String funcName = s.substring(0, s.indexOf(':'));
			String varName = s.substring(s.indexOf(':') + 1);
			
			int lineNum = ((PLDeclaration) prog.getFunctions().get(funcName)
					.getVariables().get(varName)).getLineNum();
			
			data.allDefsLineNums.add(lineNum);
		}
		
		// See if everything was actually covered
		for (DCPath path: data.coveredDCPaths) {
			if (!data.coveredForAllDefs.contains(path.getId())) {
				data.coveredForAllDefs.add(path.getId());
			}
		}
	}

	public void generateAllCUses(ProcessorData data) {
		// See what needs to be covered
		for (DCPath path: data.allDCPaths) {
			if (!data.requiredForAllCUses.contains(path) && path.isCUse()) {
				data.requiredForAllCUses.add(path);
			}
		}
		
		// See if everything was actually covered
		for (DCPath path: data.coveredDCPaths) {
			if (!data.coveredForAllCUses.contains(path) && path.isCUse()) {
				data.coveredForAllCUses.add(path);
			}
		}
	}

	public void generateAllPUses(ProcessorData data) {
		// See what needs to be covered
		for (DCPath path: data.allDCPaths) {
			if (!data.requiredForAllPUses.contains(path) && !path.isCUse()) {
				data.requiredForAllPUses.add(path);
			}
		}
		
		// See if everything was actually covered
		for (DCPath path: data.coveredDCPaths) {
			if (!data.coveredForAllPUses.contains(path) && !path.isCUse()) {
				data.coveredForAllPUses.add(path);
			}
		}
	}
}
